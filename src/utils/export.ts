/**
 * Export Format Generators
 */

import type { ExportFormat } from '../types/cc1101';
import { CC1101_REGISTERS } from '../data/registers';
import { toHex } from './calculations';

/**
 * Generate Flipper Zero Custom_preset_data format
 */
export function generateFlipperPresetData(
  registers: Record<number, number>,
  paTable: number[]
): string {
  const parts: string[] = [];

  // Check sync mode from MDMCFG2 to determine if SYNC words should be included
  const mdmcfg2 = registers[0x12] ?? 0x13; // Default value
  const syncMode = mdmcfg2 & 0x03; // Bits 1:0
  const isSyncEnabled = syncMode !== 0;

  // Add register address-value pairs (only those meant for Flipper export)
  for (let addr = 0; addr <= 0x2E; addr++) {
    const value = registers[addr];
    const regDef = CC1101_REGISTERS[addr];
    
    // Skip SYNC1/SYNC0 if sync mode is disabled
    if ((addr === 0x04 || addr === 0x05) && !isSyncEnabled) {
      continue;
    }
    
    // Only include if explicitly marked for Flipper export
    if (value !== undefined && regDef?.flipperExport === true) {
      parts.push(toHex(addr));
      parts.push(toHex(value));
    }
  }

  // Add terminator
  parts.push('00', '00');

  // Add PA table
  paTable.forEach(byte => {
    parts.push(toHex(byte));
  });

  return parts.join(' ');
}

/**
 * Generate setting_user format
 */
export function generateFlipperSettingUser(
  presetName: string,
  registers: Record<number, number>,
  paTable: number[]
): string {
  return `Custom_preset_name: ${presetName}
Custom_preset_module: CC1101
Custom_preset_data: ${generateFlipperPresetData(registers, paTable)}`;
}

/**
 * Generate C array format
 */
export function generateCArray(
  presetName: string,
  registers: Record<number, number>,
  paTable: number[]
): string {
  const safeName = presetName.replace(/[^a-zA-Z0-9_]/g, '_');
  let output = `// CC1101 Register Configuration: ${presetName}\n`;
  output += `// Generated by CC1101 Register Editor\n\n`;
  output += `static const uint8_t ${safeName}_registers[] = {\n`;

  for (let addr = 0; addr <= 0x2E; addr++) {
    const value = registers[addr];
    const reg = CC1101_REGISTERS[addr];
    if (value !== undefined && reg) {
      output += `    0x${toHex(value)},  // 0x${toHex(addr)} ${reg.name}\n`;
    }
  }

  output += `};\n\n`;
  output += `static const uint8_t ${safeName}_pa_table[] = {\n    `;
  output += paTable.map(b => `0x${toHex(b)}`).join(', ');
  output += `\n};\n`;

  return output;
}

/**
 * Generate raw hex format
 */
export function generateRawHex(registers: Record<number, number>): string {
  const parts: string[] = [];
  for (let addr = 0; addr <= 0x2E; addr++) {
    const value = registers[addr];
    if (value !== undefined) {
      parts.push(toHex(value));
    }
  }
  return parts.join(' ');
}

/**
 * Generate export based on format
 */
export function generateExport(
  format: ExportFormat,
  presetName: string,
  registers: Record<number, number>,
  paTable: number[]
): string {
  switch (format) {
    case 'flipper_setting':
      return generateFlipperSettingUser(presetName, registers, paTable);
    case 'c_array':
      return generateCArray(presetName, registers, paTable);
    case 'raw_hex':
      return generateRawHex(registers);
    default:
      return '';
  }
}

/**
 * Parse Flipper Custom_preset_data format
 */
export function parseFlipperPresetData(
  data: string
): { registers: Record<number, number>; paTable: number[] } {
  const cleanData = data.replace(/Custom_preset_data:\s*/i, '').trim();
  const bytes = cleanData.split(/\s+/).map(b => parseInt(b, 16));

  const registers: Record<number, number> = {};
  for (let addr = 0; addr <= 0x2E; addr++) {
    registers[addr] = 0;
  }
  const paTable: number[] = [];

  let i = 0;
  while (i < bytes.length - 2) {
    const addr = bytes[i];
    const value = bytes[i + 1];

    if (addr === 0 && value === 0) {
      // Next 8 bytes are PA table
      for (let j = 0; j < 8 && i + 2 + j < bytes.length; j++) {
        paTable.push(bytes[i + 2 + j]);
      }
      break;
    }

    if (addr <= 0x2E) {
      registers[addr] = value;
    }
    i += 2;
  }

  return { registers, paTable };
}

/**
 * Parse raw hex (just register values in order)
 */
export function parseRawHex(data: string): Record<number, number> {
  const bytes = data.trim().split(/\s+/).map(b => parseInt(b, 16));
  const registers: Record<number, number> = {};

  for (let i = 0; i < Math.min(bytes.length, 0x2F); i++) {
    if (!isNaN(bytes[i])) {
      registers[i] = bytes[i];
    }
  }

  return registers;
}
